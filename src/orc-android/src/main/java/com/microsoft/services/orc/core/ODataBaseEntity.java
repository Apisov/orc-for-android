
/**
 * ****************************************************************************
 * Copyright (c) Microsoft Open Technologies, Inc. All Rights Reserved.
 * Licensed under the MIT or Apache License; see LICENSE in the source repository
 * root for authoritative license information.ï»¿
 * <p/>
 * *NOTE** This code was generated by a tool and will occasionally be
 * overwritten. We welcome comments and issues regarding this code; they will be
 * addressed in the generation tool. If you wish to submit pull requests, please
 * do so for the templates in that tool.
 * <p/>
 * This code was generated by Vipr (https://github.com/microsoft/vipr) using
 * the T4TemplateWriter (https://github.com/msopentech/vipr-t4templatewriter).
 * ****************************************************************************
 */
package com.microsoft.services.orc.core;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * The type ODataBaseEntity.
 */
public class ODataBaseEntity {

    /**
     * The $$ __ o data type.
     */
    protected String $$__ODataType;

    /**
     * The $$$ __ $$$ updated values.
     */
    Set<String> $$$__$$$updatedValues = new HashSet<String>();

    /**
     * Sets o data type.
     *
     * @param value the value
     */
    protected void setODataType(String value) {
        this.$$__ODataType = value;
    }

    /**
     * Gets updated values.
     *
     * @return the updated values
     */
    public Map<String, Object> getUpdatedValues() {
        try {
            Map<String, Object> data = new HashMap<String, Object>();
            Iterable<? extends Field> fields = getAllFields();

            for (Field field : fields) {
                if ($$$__$$$updatedValues.contains(field.getName())) {
                    field.setAccessible(true);

                    if (ODataBaseEntity.class.isAssignableFrom(field.getType())) {
                        ODataBaseEntity oDataBaseEntity = ((ODataBaseEntity) field.get(this));
                        if (oDataBaseEntity!= null) {
                            data.put(field.getName(), oDataBaseEntity.getAllValues());
                        } else {
                            data.put(field.getName(), null);
                        }
                    } else {
                        data.put(field.getName(), field.get(this));
                    }
                } else {
                    if (ODataBaseEntity.class.isAssignableFrom(field.getType())) {
                        field.setAccessible(true);
                        ODataBaseEntity oDataBaseEntity = ((ODataBaseEntity) field.get(this));
                        if (oDataBaseEntity != null) {
                            Map<String, Object> internalData = oDataBaseEntity.getUpdatedValues();

                            if (internalData.size() > 0) {
                                data.put(field.getName(), oDataBaseEntity.getAllValues());
                            }
                        }
                    } else if (List.class.isAssignableFrom(field.getType())) {
                        field.setAccessible(true);

                        List<?> list = (List<?>) field.get(this);

                        if (hasListChanged(list)) {
                            data.put(field.getName(), list);
                        }
                    }
                }
            }

            return data;
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @return All the object fields and values for the object
     * @throws IllegalAccessException
     */
    private Map<String, Object> getAllValues() throws IllegalAccessException {
        Map<String, Object> data = new HashMap<String, Object>();
        Iterable<? extends Field> fields = getAllFields();

        for (Field field : fields) {
            field.setAccessible(true);
            Object val = field.get(this);
            data.put(field.getName(), val);
        }

        return data;
    }

    /**
     * @return all the object fields
     */
    public Iterable<? extends Field> getAllFields() {
        Class clazz=this.getClass();
        List<Field> fields = new ArrayList<Field>();

        while (clazz != Object.class) {
            for (Field f : clazz.getDeclaredFields()) {
                fields.add(f);
            }

            clazz = clazz.getSuperclass();
        }

        return fields;
    }

    private boolean hasListChanged(List<?> list) throws IllegalAccessException {

        if (list == null) {
            return false;
        }

        if(!(list instanceof ChangesTrackingList) || (list instanceof ChangesTrackingList && ((ChangesTrackingList) list).hasChanged())) {
            return true;
        }
        else {
            if (list.size() > 0) {

                if (list.get(0) instanceof ODataBaseEntity || list.get(0) instanceof List) {

                    for (Object elem : list) {
                        if (elem instanceof List) {
                            return hasListChanged((List)elem);
                        }
                        else
                        {
                            Map<String, Object> internalData = ((ODataBaseEntity)elem).getUpdatedValues();

                            if (internalData.size() > 0) {
                                return true;
                            }
                        }
                    }
                }

            }
        }

        return false;
    }

    /**
     * Value changed.
     *
     * @param property the property
     * @param payload the payload
     */
    public void valueChanged(String property, Object payload) {
        $$$__$$$updatedValues.add(property);
    }
}
